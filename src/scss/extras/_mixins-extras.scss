/**
 * @file
 * Extra mixins.
 */

/**
 * Grid-rhythm-matching vertical gaps.
 *
 * Attempts to provide a gap that is approximately equal to the visual width
 * of one column (including gutters) on a 24 (!) column grid at the given
 * screen-width.
 * 
 * Works well at exactly 'wide-mt-min' breakpoint and on screens >= 'wide-max'.
 * In the rest of the cases it's just "close enough".
 */
@mixin vertical-gap($implemented_as: margin, $which: both, $multiplier: 1) {

  // We need to use keys here sparingly, because when this gets used, for every
  // key in here there will be a chunk of CSS generated.
  $vertical-gap-values: (
    narrow-min: 2rem,
    wide-mt-min:   rem-calc(map-get($breakpoints, wide-mt-min)/24) + rem-calc(map-get($grid-column-gutter, wide-min)),
    wide-max:   rem-calc($page-max-width/24) + rem-calc(map-get($grid-column-gutter, wide-min))
  );

  @each $breakpoint, $gap in $vertical-gap-values {
    @include breakpoint($breakpoint) {
      @if $which == (both) {
        #{$implemented_as}-top: $gap * $multiplier;
        #{$implemented_as}-bottom: $gap * $multiplier;
      }
      @else {
        #{$implemented_as}-#{$which}: $gap * $multiplier;
      }
    }
  }
}

/**
 * Offsets text-containing elements so that texts align better to bounding box.
 *
 * @param $line-height
 *   The prevailing line-height in the current DOM-subtree.
 * @param $pos
 *   Position, either `top` or `bottom`.
 * @param $correction
 *   Number, allows for custom adjustments, which might be neccessary,
 *   depending on the characteristics of the actual font being used.
 */
@mixin line-height-fit($line-height, $pos, $correction: 0) {
  // Take the part of line-height that's above 1, half it (as it is distributed
  // on the top and the bottom), apply correction, then add an em unit on it.
  $offset: ($line-height - 1) * 0.5 * (1 + $correction);
  $offset-w-unit: $offset * 1em;
  margin-#{$pos}: -$offset-w-unit;
}

